//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	"log"
	"os"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

const marker = "// generate:reset"

const templateStr = `// Code generated by reset generator; DO NOT EDIT.

package {{.Package}}
{{range .Entries}}
func (x *{{.Name}}) Reset() {
{{- range .Body}}
{{.}}
{{- end}}
}
{{end}}
`

var tmpl = template.Must(template.New("reset").Parse(templateStr))

type templateData struct {
	Package string
	Entries []structEntry
}

type structEntry struct {
	Name string
	Body []string
}

func main() {
	fset := token.NewFileSet()

	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedName | packages.NeedSyntax | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedFiles,
		Fset: fset,
	}, "./...")
	if err != nil {
		log.Fatal(err)
	}

	for _, pkg := range pkgs {
		if len(pkg.Syntax) == 0 {
			continue
		}

		data := templateData{Package: pkg.Name}
		for _, file := range pkg.Syntax {
			for _, decl := range file.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok || genDecl.Doc == nil || !hasMarker(genDecl.Doc) {
					continue
				}

				for _, spec := range genDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}

					structType, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						continue
					}

					typeName := typeSpec.Name.Name
					if typeSpec.TypeParams != nil && len(typeSpec.TypeParams.List) > 0 {
						var params []string
						for _, p := range typeSpec.TypeParams.List {
							for _, n := range p.Names {
								if n != nil && n.Name != "" {
									params = append(params, n.Name)
								}
							}
						}
						if len(params) > 0 {
							typeName = fmt.Sprintf("%s[%s]", typeName, strings.Join(params, " | "))
						}
					}

					entry := structEntry{Name: typeName}
					for _, field := range structType.Fields.List {
						if len(field.Names) == 0 {
							continue
						}

						statement := "x." + field.Names[0].Name
						resetCode := generateResetForField(pkg, statement, field.Type)
						if resetCode != "" {
							entry.Body = append(entry.Body, resetCode)
						}
					}
					data.Entries = append(data.Entries, entry)
				}
			}
		}

		if len(data.Entries) == 0 {
			continue
		}

		err = writeToFile(pkg, data)
		if err != nil {
			log.Fatal(err)
		}
	}
}

func writeToFile(pkg *packages.Package, data templateData) error {
	var (
		buf bytes.Buffer
		err error
	)

	err = tmpl.Execute(&buf, data)
	if err != nil {
		return err
	}

	nameSplit := strings.Split(pkg.GoFiles[0], "/")
	fileName := strings.Join(nameSplit[:len(nameSplit)-1], "/") + "/reset.gen.go"

	return os.WriteFile(fileName, buf.Bytes(), 0o644)
}

func hasMarker(doc *ast.CommentGroup) bool {
	for _, c := range doc.List {
		if strings.TrimSpace(c.Text) == marker {
			return true
		}
	}
	return false
}

func generateResetForField(pkg *packages.Package, statement string, fieldExpr ast.Expr) string {
	typ := pkg.TypesInfo.TypeOf(fieldExpr)
	if typ == nil {
		return ""
	}

	if hasResetMethod(typ) {
		return fmt.Sprintf("\t%s.Reset()", statement)
	}

	switch t := typ.(type) {
	case *types.Pointer:
		elem := t.Elem()
		if hasResetMethod(elem) {
			return fmt.Sprintf("\tif %s != nil {\n\t\t%s.Reset()\n\t}", statement, statement)
		}
		return fmt.Sprintf("\t%s = nil", statement)

	case *types.Slice:
		return fmt.Sprintf("\t%s = %s[:0]", statement, statement)

	case *types.Map:
		return fmt.Sprintf("\tclear(%s)", statement)

	case *types.Array:
		return fmt.Sprintf("\t%s = %s{}", statement, typeString(pkg, typ))

	case *types.Named:
		if _, ok := t.Underlying().(*types.Struct); ok {
			return fmt.Sprintf("\t%s = %s{}", statement, typeString(pkg, typ))
		}
	}

	switch typ.String() {
	case "string":
		return fmt.Sprintf("\t%s = \"\"", statement)
	case "bool":
		return fmt.Sprintf("\t%s = false", statement)
	case "int",
		"int8",
		"int16",
		"int32",
		"int64",
		"uint",
		"uint8",
		"uint16",
		"uint32",
		"uint64",
		"float32",
		"float64",
		"rune",
		"byte":
		return fmt.Sprintf("\t%s = 0", statement)
	}

	if _, ok := typ.(*types.TypeParam); ok {
		return fmt.Sprintf("\t%s = *new(%s)", statement, typeString(pkg, typ))
	}

	panic("unsupported field type: " + typeString(pkg, typ))
}

func hasResetMethod(typ types.Type) bool {
	typesToCheck := []types.Type{typ, types.NewPointer(typ)}
	for _, t := range typesToCheck {
		ms := types.NewMethodSet(t)
		if sel := ms.Lookup(nil, "Reset"); sel != nil {
			sig, ok := sel.Obj().Type().(*types.Signature)
			if ok && sig.Params().Len() == 0 && sig.Results().Len() == 0 {
				return true
			}
		}
	}
	return false
}

func typeString(pkg *packages.Package, typ types.Type) string {
	return types.TypeString(typ, func(other *types.Package) string {
		if other.Path() == pkg.Types.Path() {
			return ""
		}
		return other.Name()
	})
}
